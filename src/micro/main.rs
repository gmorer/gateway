use std::{ io, pin::Pin };
use services::contact::Contacts;
use futures::future;
use futures::prelude::*;
use tarpc::{ context };
use tarpc::rpc::server::{ self, Handler, Channel };
use tokio_serde::formats::Json;
use tokio::time::delay_for;
use std::time::Duration;

/*
	modules : method : body
*/

#[derive(Clone)]
struct ContactService();

const ADDR: &str = "127.0.0.1:8080";

impl Contacts for ContactService {
	// type TestFut = Ready<u32>;
	type TestFut = Pin<Box<dyn Future<Output = Result<u32, String>> + Send>>;
	fn test(self, _context: context::Context, i: u32) -> Self::TestFut {
		async fn test(i: u32) -> Result<u32, String> {
			println!("receive {}", i);
			delay_for(Duration::from_secs(i as u64)).await;
			Ok(i * 2)
		}
		test(i).boxed()
	}
}

#[tokio::main]
async fn main() -> io::Result<()> {
	tarpc::serde_transport::tcp::listen(ADDR, Json::default)
		.await?
		// Ignore accept errors.
		.filter_map(|r| future::ready(r.ok()))
		.map(server::BaseChannel::with_defaults)
		// Limit channels to 1 per IP.
		.max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = ContactService();
            channel.respond_with(server.serve()).execute()
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
	// task::block_on(try_main())
	Ok(())
}
